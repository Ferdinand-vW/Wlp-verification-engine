module {SyntaxTransformer}
{
Stmt(..), Expr(..), stmt_trans
}
{
import qualified Data.Map as M
import qualified Data.Set as S
import qualified Data.List as L
import Data.SBV(SInteger)
}


include "Grammar.ag"

{
stmt_trans :: Stmt -> Stmt
stmt_trans stmt = transformed_Syn_Top $ wrap_Top (sem_Top (Top stmt)) (Inh_Top)
}

data Top | Top stmt :: Stmt

attr Top
  syn transformed :: Stmt

sem Top
  | Top lhs.transformed = @stmt.fresh
        stmt.varMap = M.empty
        stmt.vars   = S.toList @stmt.allVars
        stmt.countInh = 0

attr Body Stmt Exprs Expr
  syn allVars :: {S.Set String}
  syn fresh :: self
  inh countInh :: Int
  syn countSyn :: Int
  inh vars :: {[String]}
  inh varMap :: {M.Map String String}

sem Stmt
  | Var     lhs.allVars       = S.union (S.fromList @vars) @body.allVars
            lhs.countSyn      = @body.countSyn
            body.countInh     = @lhs.countInh + 1
            lhs.fresh         = Var (L.union @loc.remVars @loc.freshVars) @body.fresh
            body.vars         = @lhs.vars
            body.varMap       = M.union @loc.freshVarsMap @lhs.varMap
            loc.dupVars       = L.intersect @lhs.vars @vars
            loc.freshVars     = map (++ show @lhs.countInh) @loc.dupVars
            loc.freshVarsMap  = M.fromList $ zip @loc.dupVars @loc.freshVars
            loc.remVars       = @vars L.\\ @loc.dupVars
  | Prog    lhs.allVars  = @body.allVars
            lhs.countSyn = @body.countSyn
            body.countInh = @lhs.countInh + 1
            lhs.fresh = Prog @name (L.union @loc.remVars @loc.freshVars) @body.fresh
            loc.dupVars = L.intersect @lhs.vars @params
            loc.freshVars = map (++ show @lhs.countInh) @loc.dupVars
            loc.freshVarsMap = M.fromList $ zip @loc.dupVars @loc.freshVars
            loc.remVars = @params L.\\ @loc.dupVars
  | Pre     lhs.allVars  = S.empty
            lhs.countSyn = @lhs.countInh
            lhs.fresh = Pre @expr.fresh
            expr.vars = @lhs.vars
            expr.varMap = @lhs.varMap
  | Post    lhs.allVars  = S.empty
            lhs.countSyn = @lhs.countInh
            lhs.fresh = Post @expr.fresh
            expr.vars = @lhs.vars
            expr.varMap = @lhs.varMap
  | Inv     lhs.allVars  = @stmt.allVars
            lhs.countSyn = @stmt.countSyn
            lhs.fresh = Inv @expr.fresh @stmt.fresh
            stmt.countInh = @lhs.countInh
            stmt.vars = @lhs.vars
            stmt.varMap = @lhs.varMap
            expr.vars = @lhs.vars
            expr.varMap = @lhs.varMap
  | While   lhs.allVars  = @body.allVars
            lhs.countSyn = @body.countSyn
            lhs.fresh = While @expr.fresh @body.fresh
            body.countInh = @lhs.countInh
            body.vars = @lhs.vars
            body.varMap = @lhs.varMap
            expr.vars = @lhs.vars
            expr.varMap = @lhs.varMap
  | If      lhs.allVars  = S.union @left.allVars @right.allVars
            lhs.countSyn = @right.countSyn
            left.countInh = @lhs.countInh
            right.countInh = @left.countSyn
            lhs.fresh = If @expr.fresh @left.fresh @right.fresh
            left.vars = @lhs.vars
            left.varMap = @lhs.varMap
            right.vars = @lhs.vars
            right.varMap = @lhs.varMap
            expr.vars = @lhs.vars
            expr.varMap = @lhs.varMap
  | Assign  lhs.allVars  = S.empty
            lhs.countSyn = @lhs.countInh
            lhs.fresh = Assign @expr1.fresh @expr2.fresh
            expr1.vars = @lhs.vars
            expr2.vars = @lhs.vars
            expr1.varMap = @lhs.varMap
            expr2.varMap = @lhs.varMap
  | Skip    lhs.allVars  = S.empty
            lhs.countSyn = @lhs.countInh
            lhs.fresh = Skip

sem Body
  | Cons lhs.allVars = S.union @hd.allVars @tl.allVars
         lhs.fresh   = @hd.fresh : @tl.fresh
         lhs.countSyn = @tl.countSyn
         hd.countInh = @lhs.countInh
         tl.countInh = @hd.countSyn
         hd.vars = @lhs.vars
         tl.vars = @lhs.vars
         hd.varMap = @lhs.varMap
         tl.varMap = @lhs.varMap
  | Nil  lhs.allVars = S.empty
         lhs.fresh   = []
         lhs.countSyn = @lhs.countInh

sem Exprs
  | Cons lhs.allVars = S.union @hd.allVars @tl.allVars
         lhs.fresh = @hd.fresh : @tl.fresh
         lhs.countSyn = @tl.countSyn
         hd.countInh = @lhs.countInh
         tl.countInh = @hd.countSyn
         hd.vars = @lhs.vars
         tl.vars = @lhs.vars
         hd.varMap = @lhs.varMap
         tl.varMap = @lhs.varMap
  | Nil  lhs.allVars = S.empty
          lhs.fresh = []
         lhs.countSyn = @lhs.countInh

sem Expr
  | Lit     lhs.allVars = S.empty
            lhs.fresh = Lit @i
            lhs.countSyn = @lhs.countInh
            
  | Name    lhs.allVars = S.empty
            lhs.fresh = case M.lookup @var @lhs.varMap of
                            Nothing -> Name @var
                            Just s -> Name s
            lhs.countSyn = @lhs.countInh
  | PCall   lhs.allVars = S.empty
            lhs.fresh = PCall @name @args.fresh
            lhs.countSyn = @args.countSyn
            args.countInh = @lhs.countInh
  | ForAll  lhs.allVars = S.singleton @var
            lhs.fresh = ForAll @loc.lookup @expr.fresh
            lhs.countSyn = @expr.countSyn
            expr.countInh = @lhs.countInh + 1
            expr.vars = @lhs.vars
            expr.varMap = 
              case @loc.lookup == @var of
                True -> M.insert @var @var @lhs.varMap
                False -> M.adjust (\_ -> @loc.lookup) @var @lhs.varMap
            loc.lookup = case L.find(== @var) @lhs.vars of
                            Nothing -> @var
                            Just s -> s ++ (show @lhs.countInh)
  | Minus   lhs.allVars = S.union @expr1.allVars @expr2.allVars 
            lhs.fresh = Minus @expr1.fresh @expr2.fresh
            lhs.countSyn = @expr2.countSyn
            expr1.countInh = @lhs.countInh
            expr2.countInh = @expr1.countSyn
            expr1.vars = @lhs.vars
            expr2.vars = @lhs.vars
            expr1.varMap = @lhs.varMap
            expr2.varMap = @lhs.varMap              
  | Plus    lhs.allVars = S.union @expr1.allVars @expr2.allVars
            lhs.fresh = Plus @expr1.fresh @expr2.fresh
            lhs.countSyn = @expr2.countSyn
            expr1.countInh = @lhs.countInh
            expr2.countInh = @expr1.countSyn
            expr1.vars = @lhs.vars
            expr2.vars = @lhs.vars
            expr1.varMap = @lhs.varMap
            expr2.varMap = @lhs.varMap 
  | Equal   lhs.allVars = S.union @expr1.allVars @expr2.allVars
            lhs.fresh = Equal @expr1.fresh @expr2.fresh
            lhs.countSyn = @expr2.countSyn
            expr1.countInh = @lhs.countInh
            expr2.countInh = @expr1.countSyn
            expr1.vars = @lhs.vars
            expr2.vars = @lhs.vars
            expr1.varMap = @lhs.varMap
            expr2.varMap = @lhs.varMap
  | Lower   lhs.allVars = S.union @expr1.allVars @expr2.allVars
            lhs.fresh = Lower @expr1.fresh @expr2.fresh
            lhs.countSyn = @expr2.countSyn
            expr1.countInh = @lhs.countInh
            expr2.countInh = @expr1.countSyn
            expr1.vars = @lhs.vars
            expr2.vars = @lhs.vars
            expr1.varMap = @lhs.varMap
            expr2.varMap = @lhs.varMap 
  | LowerE  lhs.allVars = S.union @expr1.allVars @expr2.allVars
            lhs.fresh = LowerE @expr1.fresh @expr2.fresh
            lhs.countSyn = @expr2.countSyn
            expr1.countInh = @lhs.countInh
            expr2.countInh = @expr1.countSyn
            expr1.vars = @lhs.vars
            expr2.vars = @lhs.vars
            expr1.varMap = @lhs.varMap
            expr2.varMap = @lhs.varMap 
  | And     lhs.allVars = S.union @expr1.allVars @expr2.allVars
            lhs.fresh = And @expr1.fresh @expr2.fresh
            lhs.countSyn = @expr2.countSyn
            expr1.countInh = @lhs.countInh
            expr2.countInh = @expr1.countSyn
            expr1.vars = @lhs.vars
            expr2.vars = @lhs.vars
            expr1.varMap = @lhs.varMap
            expr2.varMap = @lhs.varMap 
  | Or      lhs.allVars = S.union @expr1.allVars @expr2.allVars
            lhs.fresh = Or @expr1.fresh @expr2.fresh
            lhs.countSyn = @expr2.countSyn
            expr1.countInh = @lhs.countInh
            expr2.countInh = @expr1.countSyn
            expr1.vars = @lhs.vars
            expr2.vars = @lhs.vars
            expr1.varMap = @lhs.varMap
            expr2.varMap = @lhs.varMap 
  | Impl    lhs.allVars = S.union @expr1.allVars @expr2.allVars
            lhs.fresh = Impl @expr1.fresh @expr2.fresh
            lhs.countSyn = @expr2.countSyn
            expr1.countInh = @lhs.countInh
            expr2.countInh = @expr1.countSyn
            expr1.vars = @lhs.vars
            expr2.vars = @lhs.vars
            expr1.varMap = @lhs.varMap
            expr2.varMap = @lhs.varMap 
  | Not     lhs.allVars = @expr.allVars
            lhs.fresh = Not @expr.fresh
            lhs.countSyn = @expr.countSyn
            expr.countInh = @lhs.countInh
            expr.vars = @lhs.vars
            expr.varMap = @lhs.varMap
  | Repby   lhs.allVars = S.union (S.union @expr1.allVars @expr2.allVars) @expr3.allVars
            lhs.fresh = Repby @expr1.fresh @expr2.fresh @expr3.fresh
            lhs.countSyn = @expr3.countSyn
            expr1.countInh = @lhs.countInh
            expr2.countInh = @expr1.countSyn
            expr3.countInh = @expr2.countSyn
            expr1.vars = @lhs.vars
            expr2.vars = @lhs.vars
            expr3.vars = @lhs.vars
            expr1.varMap = @lhs.varMap
            expr2.varMap = @lhs.varMap
            expr3.varMap = @lhs.varMap
  | True_   lhs.allVars = S.empty
            lhs.fresh = True_
            lhs.countSyn = @lhs.countInh