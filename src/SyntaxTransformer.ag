module {SyntaxTransformer}
{
Stmt(..), Expr(..), stmt_fresh, stmt_prog
}
{
import qualified Data.Map as M
import qualified Data.Set as S
import qualified Data.List as L
import Data.Maybe
import Data.SBV(SInteger)
}


include "Grammar.ag"

{
stmt_fresh :: Stmt -> Stmt
stmt_fresh stmt = fresh_Syn_Top $ wrap_Top (sem_Top (Top stmt)) Inh_Top
stmt_prog :: Stmt -> Stmt
stmt_prog stmt = prog_Syn_Top $ wrap_Top (sem_Top (Top stmt)) Inh_Top
}

data Top | Top stmt :: Stmt

attr Top
  syn fresh :: Stmt
  syn prog :: Stmt

sem Top
  | Top lhs.fresh = @stmt.fresh
        stmt.varMap = M.empty
        stmt.vars   = S.toList @stmt.allVars
        stmt.countInh = 0
        stmt.allProgs = @stmt.findProgs
        lhs.prog = @stmt.prog

attr Body Stmt Exprs Expr
  syn allVars :: {S.Set String}
  syn fresh :: self
  inh countInh :: Int
  syn countSyn :: Int
  inh vars :: {[String]}
  inh varMap :: {M.Map String String}

sem Stmt
  | Var     lhs.allVars       = S.union (S.fromList @vars) @body.allVars
            lhs.countSyn      = @body.countSyn
            body.countInh     = @lhs.countInh + 1
            lhs.fresh         = Var (L.union @loc.remVars @loc.freshVars) @body.fresh
            body.vars         = @lhs.vars
            body.varMap       = M.union @loc.freshVarsMap @lhs.varMap
            loc.dupVars       = L.intersect @lhs.vars @vars
            loc.freshVars     = map (++ show @lhs.countInh) @loc.dupVars
            loc.freshVarsMap  = M.fromList $ zip @loc.dupVars @loc.freshVars
            loc.remVars       = @vars L.\\ @loc.dupVars
  | Prog    lhs.allVars  = S.union (S.union (S.fromList @params) @body.allVars) (S.fromList @results)
            lhs.countSyn = @body.countSyn
            body.countInh = @lhs.countInh + 1
            body.vars = @lhs.vars
            body.varMap = M.union (M.union @loc.freshVarsMap @lhs.varMap) @loc.freshVarsRMap
            lhs.fresh = Prog @name (L.union @loc.remVars @loc.freshVars) (L.union @loc.remVarsR @loc.freshVarsR) @body.fresh
            loc.dupVars = L.intersect @lhs.vars @params
            loc.dupVarsR = L.intersect @lhs.vars @results
            loc.freshVars = map (++ show @lhs.countInh) @loc.dupVars
            loc.freshVarsR = map (++ show @lhs.countInh) @loc.dupVarsR
            loc.freshVarsMap = M.fromList $ zip @loc.dupVars @loc.freshVars
            loc.freshVarsRMap = M.fromList $ zip @loc.dupVarsR @loc.freshVarsR
            loc.remVars = @params L.\\ @loc.dupVars
            loc.remVarsR = @results L.\\ @loc.dupVarsR
  | PCall   lhs.allVars = S.empty
            lhs.fresh = PCall @name @args.fresh @res.fresh
            lhs.countSyn = @args.countSyn
            args.countInh = @lhs.countInh
  | Pre     lhs.allVars  = S.empty
            lhs.countSyn = @lhs.countInh
            lhs.fresh = Pre @expr.fresh
            expr.vars = @lhs.vars
            expr.varMap = @lhs.varMap
  | Post    lhs.allVars  = S.empty
            lhs.countSyn = @lhs.countInh
            lhs.fresh = Post @expr.fresh
            expr.vars = @lhs.vars
            expr.varMap = @lhs.varMap
  | Inv     lhs.allVars  = @stmt.allVars
            lhs.countSyn = @stmt.countSyn
            lhs.fresh = Inv @expr.fresh @stmt.fresh
            stmt.countInh = @lhs.countInh
            stmt.vars = @lhs.vars
            stmt.varMap = @lhs.varMap
            expr.vars = @lhs.vars
            expr.varMap = @lhs.varMap
  | While   lhs.allVars  = @body.allVars
            lhs.countSyn = @body.countSyn
            lhs.fresh = While @expr.fresh @body.fresh
            body.countInh = @lhs.countInh
            body.vars = @lhs.vars
            body.varMap = @lhs.varMap
            expr.vars = @lhs.vars
            expr.varMap = @lhs.varMap
  | If      lhs.allVars  = S.union @left.allVars @right.allVars
            lhs.countSyn = @right.countSyn
            left.countInh = @lhs.countInh
            right.countInh = @left.countSyn
            lhs.fresh = If @expr.fresh @left.fresh @right.fresh
            left.vars = @lhs.vars
            left.varMap = @lhs.varMap
            right.vars = @lhs.vars
            right.varMap = @lhs.varMap
            expr.vars = @lhs.vars
            expr.varMap = @lhs.varMap
  | Assign  lhs.allVars  = S.empty
            lhs.countSyn = @lhs.countInh
            lhs.fresh = Assign @expr1.fresh @expr2.fresh
            expr1.vars = @lhs.vars
            expr2.vars = @lhs.vars
            expr1.varMap = @lhs.varMap
            expr2.varMap = @lhs.varMap
  | Skip    lhs.allVars  = S.empty
            lhs.countSyn = @lhs.countInh
            lhs.fresh = Skip

sem Body
  | Cons lhs.allVars = S.union @hd.allVars @tl.allVars
         lhs.fresh   = @hd.fresh : @tl.fresh
         lhs.countSyn = @tl.countSyn
         hd.countInh = @lhs.countInh
         tl.countInh = @hd.countSyn
         hd.vars = @lhs.vars
         tl.vars = @lhs.vars
         hd.varMap = @lhs.varMap
         tl.varMap = @lhs.varMap
  | Nil  lhs.allVars = S.empty
         lhs.fresh   = []
         lhs.countSyn = @lhs.countInh

sem Exprs
  | Cons lhs.allVars = S.union @hd.allVars @tl.allVars
         lhs.fresh = @hd.fresh : @tl.fresh
         lhs.countSyn = @tl.countSyn
         hd.countInh = @lhs.countInh
         tl.countInh = @hd.countSyn
         hd.vars = @lhs.vars
         tl.vars = @lhs.vars
         hd.varMap = @lhs.varMap
         tl.varMap = @lhs.varMap
  | Nil  lhs.allVars = S.empty
          lhs.fresh = []
         lhs.countSyn = @lhs.countInh

sem Expr
  | Lit     lhs.allVars = S.empty
            lhs.fresh = Lit @i
            lhs.countSyn = @lhs.countInh
            
  | Name    lhs.allVars = S.empty
            lhs.fresh = case M.lookup @var @lhs.varMap of
                            Nothing -> Name @var
                            Just s -> Name s
            lhs.countSyn = @lhs.countInh
  | ForAll  lhs.allVars = S.singleton @var
            lhs.fresh = ForAll @loc.lookup @expr.fresh
            lhs.countSyn = @expr.countSyn
            expr.countInh = @lhs.countInh + 1
            expr.vars = @lhs.vars
            expr.varMap = 
              case @loc.lookup == @var of
                True -> M.insert @var @var @lhs.varMap
                False -> M.adjust (\_ -> @loc.lookup) @var @lhs.varMap
            loc.lookup = case L.find(== @var) @lhs.vars of
                            Nothing -> @var
                            Just s -> s ++ (show @lhs.countInh)
  | Minus   lhs.allVars = S.union @expr1.allVars @expr2.allVars 
            lhs.fresh = Minus @expr1.fresh @expr2.fresh
            lhs.countSyn = @expr2.countSyn
            expr1.countInh = @lhs.countInh
            expr2.countInh = @expr1.countSyn
            expr1.vars = @lhs.vars
            expr2.vars = @lhs.vars
            expr1.varMap = @lhs.varMap
            expr2.varMap = @lhs.varMap              
  | Plus    lhs.allVars = S.union @expr1.allVars @expr2.allVars
            lhs.fresh = Plus @expr1.fresh @expr2.fresh
            lhs.countSyn = @expr2.countSyn
            expr1.countInh = @lhs.countInh
            expr2.countInh = @expr1.countSyn
            expr1.vars = @lhs.vars
            expr2.vars = @lhs.vars
            expr1.varMap = @lhs.varMap
            expr2.varMap = @lhs.varMap 
  | Equal   lhs.allVars = S.union @expr1.allVars @expr2.allVars
            lhs.fresh = Equal @expr1.fresh @expr2.fresh
            lhs.countSyn = @expr2.countSyn
            expr1.countInh = @lhs.countInh
            expr2.countInh = @expr1.countSyn
            expr1.vars = @lhs.vars
            expr2.vars = @lhs.vars
            expr1.varMap = @lhs.varMap
            expr2.varMap = @lhs.varMap
  | Lower   lhs.allVars = S.union @expr1.allVars @expr2.allVars
            lhs.fresh = Lower @expr1.fresh @expr2.fresh
            lhs.countSyn = @expr2.countSyn
            expr1.countInh = @lhs.countInh
            expr2.countInh = @expr1.countSyn
            expr1.vars = @lhs.vars
            expr2.vars = @lhs.vars
            expr1.varMap = @lhs.varMap
            expr2.varMap = @lhs.varMap 
  | LowerE  lhs.allVars = S.union @expr1.allVars @expr2.allVars
            lhs.fresh = LowerE @expr1.fresh @expr2.fresh
            lhs.countSyn = @expr2.countSyn
            expr1.countInh = @lhs.countInh
            expr2.countInh = @expr1.countSyn
            expr1.vars = @lhs.vars
            expr2.vars = @lhs.vars
            expr1.varMap = @lhs.varMap
            expr2.varMap = @lhs.varMap 
  | And     lhs.allVars = S.union @expr1.allVars @expr2.allVars
            lhs.fresh = And @expr1.fresh @expr2.fresh
            lhs.countSyn = @expr2.countSyn
            expr1.countInh = @lhs.countInh
            expr2.countInh = @expr1.countSyn
            expr1.vars = @lhs.vars
            expr2.vars = @lhs.vars
            expr1.varMap = @lhs.varMap
            expr2.varMap = @lhs.varMap 
  | Or      lhs.allVars = S.union @expr1.allVars @expr2.allVars
            lhs.fresh = Or @expr1.fresh @expr2.fresh
            lhs.countSyn = @expr2.countSyn
            expr1.countInh = @lhs.countInh
            expr2.countInh = @expr1.countSyn
            expr1.vars = @lhs.vars
            expr2.vars = @lhs.vars
            expr1.varMap = @lhs.varMap
            expr2.varMap = @lhs.varMap 
  | Impl    lhs.allVars = S.union @expr1.allVars @expr2.allVars
            lhs.fresh = Impl @expr1.fresh @expr2.fresh
            lhs.countSyn = @expr2.countSyn
            expr1.countInh = @lhs.countInh
            expr2.countInh = @expr1.countSyn
            expr1.vars = @lhs.vars
            expr2.vars = @lhs.vars
            expr1.varMap = @lhs.varMap
            expr2.varMap = @lhs.varMap 
  | Not     lhs.allVars = @expr.allVars
            lhs.fresh = Not @expr.fresh
            lhs.countSyn = @expr.countSyn
            expr.countInh = @lhs.countInh
            expr.vars = @lhs.vars
            expr.varMap = @lhs.varMap
  | Repby   lhs.allVars = S.union @expr1.allVars @expr2.allVars
            lhs.fresh = Repby @expr1.fresh @expr2.fresh
            lhs.countSyn = @expr2.countSyn
            expr1.countInh = @lhs.countInh
            expr2.countInh = @expr1.countSyn
            expr1.vars = @lhs.vars
            expr2.vars = @lhs.vars
            expr1.varMap = @lhs.varMap
            expr2.varMap = @lhs.varMap
  | True_   lhs.allVars = S.empty
            lhs.fresh = True_
            lhs.countSyn = @lhs.countInh

attr Body Stmt Exprs Expr
  syn prog :: self

attr Body Stmt
  syn findProgs :: {M.Map String ([String],[String],Body)}
  inh allProgs :: {M.Map String ([String],[String],Body)}

sem Body
  | Cons  lhs.prog = @hd.prog : @tl.prog
          lhs.findProgs = M.union @hd.findProgs @tl.findProgs
          hd.allProgs = @lhs.allProgs
          tl.allProgs = @lhs.allProgs
  | Nil   lhs.prog = []
          lhs.findProgs = M.empty

sem Stmt
  | Var     lhs.prog = Var @vars @body.prog
            lhs.findProgs = @body.findProgs
            body.allProgs = @lhs.allProgs
  | Prog    lhs.prog = Prog @name @params @results @body.prog
            lhs.findProgs = M.union @loc.findProgs @body.findProgs
            loc.findProgs = M.singleton @name (@params,@results,@body.prog)
            body.allProgs = @lhs.allProgs
  | PCall   lhs.prog = Var (@loc.prms ++ @loc.res) $
                          [Assign (Name $ head @prms) (head @args.prog)]
                            ++
                          @loc.body
                            ++
                          [Assign (head @res.prog) (Name $ head @loc.res)]
            loc.prms = fst3 @loc.prog
            loc.res = snd3 @loc.prog
            loc.body = thrd @loc.prog
            loc.prog = fromJust $ M.lookup @name @lhs.allProgs
            lhs.findProgs = M.empty
  | Pre     lhs.prog = Pre @expr.prog
            lhs.findProgs = M.empty
  | Post    lhs.prog = Post @expr.prog
            lhs.findProgs = M.empty
  | Inv     lhs.prog = Inv @expr.prog @stmt.prog
            lhs.findProgs = @stmt.findProgs
  | While   lhs.prog = While @expr.prog @body.prog
            lhs.findProgs = @body.findProgs
  | If      lhs.prog = If @expr.prog @left.prog @right.prog
            lhs.findProgs = M.union @left.findProgs @right.findProgs
  | Assign  lhs.prog = Assign @expr1.prog @expr2.prog
            lhs.findProgs = M.empty
  | Skip    lhs.prog = Skip
            lhs.findProgs = M.empty

{

fst3 :: (a,b,c) -> a
fst3 (a,b,c) = a

snd3 :: (a,b,c) -> b
snd3 (a,b,c) = b

thrd :: (a,b,c) -> c
thrd (a,b,c) = c
}